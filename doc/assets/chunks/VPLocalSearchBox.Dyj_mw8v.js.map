{"version":3,"mappings":"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","names":["localSearchIndex","root","__vitePreload","import","__VITE_PRELOAD__","candidateSelectors","candidateSelector","join","NoElement","Element","matches","prototype","msMatchesSelector","webkitMatchesSelector","getRootNode","element","_element$getRootNode","call","ownerDocument","_isInert","node","lookUp","_node$getAttribute","inertAtt","getAttribute","parentNode","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","unshift","_getCandidatesIteratively","elements","options","elementsToCheck","from","length","shift","tagName","assigned","assignedElements","content","children","nestedCandidates","flatten","push","scopeParent","includes","shadowRoot","getShadowRoot","validShadowRoot","shadowRootFilter","_nestedCandidates","hasTabIndex","isNaN","parseInt","getTabIndex","Error","tabIndex","test","_node$getAttribute2","attValue","isContentEditable","sortOrderedTabbables","a","b","documentOrder","isInput","isNonTabbableRadio","type","isRadio","name","radioSet","radioScope","form","queryRadios","window","CSS","escape","err","console","error","message","checked","nodes","i","getCheckedRadio","isTabbableRadio","isZeroArea","_node$getBoundingClie","getBoundingClientRect","width","height","isHidden","_ref","displayCheck","checkVisibility","checkOpacity","opacityProperty","contentVisibilityAuto","visibilityProperty","checkVisibilityCSS","getComputedStyle","visibility","nodeUnderDetails","parentElement","originalNode","rootNode","assignedSlot","host","_nodeRoot","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","nodeRoot","nodeRootHost","attached","contains","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isNodeAttached","getClientRects","isNodeMatchingSelectorFocusable","disabled","isHiddenInput","some","child","isDetailsWithSummary","item","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","isShadowRootTabbable","shadowHostNode","_sortByOrder","regularTabbables","orderedTabbables","forEach","isScope","candidateTabindex","getSortOrderTabIndex","sort","reduce","acc","sortable","concat","isTabbable","focusableCandidateSelector","isFocusable","_arrayLikeToArray","r","e","n","_defineProperty","t","Symbol","toPrimitive","TypeError","String","Number","_toPrimitive","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","getOwnPropertyDescriptor","_objectSpread2","arguments","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","isArray","_arrayWithoutHoles","iterator","_iterableToArray","toString","constructor","_unsupportedIterableToArray","_nonIterableSpread","activeFocusTraps","trapStack","trap","activeTrap","_setPausedState","trapIndex","indexOf","splice","_isManuallyPaused","isTabEvent","key","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","fn","setTimeout","valueOrHandler","_len","params","_key","getActualTarget","event","target","composedPath","internalTrapStack","createFocusTrap","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","manuallyPaused","delayInitialFocusTimer","undefined","recentNavEvent","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","findIndex","container","tabbableNodes","find","getNodeForOption","_ref2","_ref2$hasFallback","hasFallback","_ref2$params","optionValue","querySelector","getInitialFocusNode","tabbableOptions","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","bind","tabbable","focusableNodes","focusable","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","reverse","posTabIndexesFound","nextTabbableNode","forward","nodeIdx","group","g","_getActiveElement","_tryFocus","focus","preventScroll","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref3","_ref3$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref4","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref5","_destinationGroupIndex","_destinationGroup","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","nextNode","stopImmediatePropagation","navAcrossContainers","mruContainerIdx","mruTabIdx","checkTabKey","checkKeyNav","checkEscapeKey","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","mutationObserver","MutationObserver","mutations","mutation","removedNodes","updateObservedNodes","disconnect","observe","subtree","childList","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","pause","pauseOptions","unpause","unpauseOptions","updateContainerElements","containerElements","elementsAsArray","Boolean","onPause","onPostPause","onUnpause","onPostUnpause","DOMIterator","ctx","iframes","exclude","iframesTimeout","selector","selectors","matchesSelector","mozMatchesSelector","oMatchesSelector","match","every","sel","getContexts","filteredCtx","NodeList","isPrototypeOf","isDescendant","contexts","getIframeContents","ifr","successFn","errorFn","ifrWin","contentWindow","isIframeBlank","bl","src","trim","location","href","observeIframeLoad","called","tout","listener","onIframeReady","readyState","waitForIframes","done","eachCalled","forEachIframe","handled","each","end","open","checkEnd","con","createIterator","whatToShow","createNodeIterator","createInstanceOnIframe","contents","compareNodeIframe","prevNode","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","getIteratorNode","itr","previousNode","checkIframeFilter","currIfr","ifrDict","val","handleOpenIframes","eCb","fCb","forEachNode","iterateThroughNodes","eachCb","filterCb","doneCb","retrieveNodes","ifrNode","ready","Mark$1","ie","ua","navigator","userAgent","opt","_opt","assign","className","separateWordSearch","diacritics","synonyms","accuracy","acrossElements","caseSensitive","ignoreJoiners","ignoreGroups","ignorePunctuation","wildcards","noMatch","debug","log","msg","level","escapeStr","str","replace","createRegExp","setupWildcardsRegExp","createSynonymsRegExp","setupIgnoreJoinersRegExp","createDiacriticsRegExp","createMergedBlanksRegExp","createJoinersRegExp","createWildcardsRegExp","createAccuracyRegExp","syn","sens","joinerPlaceholder","index","hasOwnProperty","k1","k2","RegExp","processSynomyms","charAt","spaces","indx","original","nextChar","joiner","split","dct","ch","ls","limiters","lsJoin","limiter","getSeparatedKeywords","sv","stack","kw","kwSplitted","keywords","isNumeric","parseFloat","checkRanges","array","last","start","valid","callNoMatchOnInvalidRanges","range","JSON","stringify","checkWhitespaceRanges","originalLength","string","max","offset","substring","getTextNodes","cb","NodeFilter","SHOW_TEXT","textContent","matchesExclude","FILTER_REJECT","FILTER_ACCEPT","wrapRangeInTextNode","hEl","startNode","splitText","ret","repl","createElement","setAttribute","replaceChild","wrapRangeInMappedTextNode","dict","sibl","s","startStr","substr","endStr","k","j","previousSibling","wrapMatches","regex","endCb","matchIdx","exec","pos","lastIndex","wrapMatchesAcrossElements","wrapRangeFromIndex","ranges","counter","unwrapMatches","parent","docFrag","createDocumentFragment","firstChild","appendChild","removeChild","normalizeTextNode","normalize","nodeType","nextSibling","nodeValue","markRegExp","regexp","totalMatches","mark","kwArr","kwArrLen","handler","term","markRanges","rawRanges","unmark","SHOW_ELEMENT","matchesSel","Mark","instance","MarkJS","KEYS","VALUES","LEAF","TreeIterator","set","_tree","_type","_path","next","dive","backtrack","last$1","result","get","pop","_prefix","recurse","query","maxDistance","results","matrix","m","prefix","distance","char","thisRowOffset","prevRowOffset","minDistance","jmin","Math","jmax","min","different","rpl","del","ins","dist","SearchableMap","tree","Map","_size","atPrefix","startsWith","path","trackDown","clear","remove","entries","fuzzyGet","maxEditDistance","Uint8Array","fill","fuzzySearch","lookup","has","createPath","size","iter","update","fetch","initial","values","fromObject","object","keyLength","outer","len","intermediate","delete","cleanup","merge","nodeKey","OR","AND","AND_NOT","MiniSearch","fields","autoVacuum","defaultAutoVacuumOptions","_options","defaultOptions","searchOptions","defaultSearchOptions","autoSuggestOptions","defaultAutoSuggestOptions","_index","_documentCount","_documentIds","_idToShortId","_fieldIds","_fieldLength","_avgFieldLength","_nextId","_storedFields","_dirtCount","_currentVacuum","_enqueuedVacuum","_enqueuedVacuumConditions","defaultVacuumConditions","addFields","add","extractField","stringifyField","tokenize","processTerm","idField","id","shortDocumentId","addDocumentId","saveStoredFields","field","fieldValue","tokens","fieldId","uniqueTerms","Set","addFieldLength","processedTerm","addTerm","addAll","documents","addAllAsync","chunkSize","chunk","promise","Promise","resolve","shortId","removeFieldLength","removeTerm","removeAll","discard","fieldLength","maybeAutoVacuum","minDirtFactor","minDirtCount","batchSize","batchWait","conditionalVacuum","discardAll","ids","updatedDocument","vacuum","conditions","performVacuuming","vacuumConditionsMet","initialDirtCount","defaultVacuumOptions","fieldsData","fieldIndex","dirtCount","dirtFactor","isVacuuming","getStoredFields","search","globalSearchOptions","searchOptionsWithDefaults","rawResults","executeQuery","docId","score","terms","quality","queryTerms","wildcard","boostDocument","byScore","autoSuggest","queryString","suggestions","phrase","suggestion","count","documentCount","termCount","loadJSON","json","loadJS","parse","loadJSONAsync","loadJSAsync","getDefault","getOwnProperty","js","documentIds","storedFields","serializationVersion","miniSearch","instantiateMiniSearch","objectToNumericMap","data","dataMap","indexEntry","ds","objectToNumericMapAsync","wait","nextId","fieldIds","averageFieldLength","executeWildcardQuery","queries","subquery","combineResults","combineWith","searchTokenize","searchProcessTerm","flatMap","termToQuerySpec","executeQuerySpec","boosts","boost","weights","maxFuzzy","bm25","bm25params","fuzzy","fuzzyWeight","prefixWeight","termResults","termBoost","prefixMatches","fuzzyMatches","round","weight","operator","combinator","combinators","toJSON","freqs","fromEntries","sourceTerm","derivedTerm","termWeight","fieldTermData","fieldBoosts","boostDocumentFn","fieldBoost","fieldTermFreqs","matchingFields","avgFieldLength","docBoost","termFreq","weightedScore","calcBM25Score","assignUniqueTerm","documentId","indexData","createMap","docs","warnDocumentChanged","fieldName","logger","fieldLengths","totalFieldLength","storeFields","documentFields","property","existing","assignUniqueTerms","combined","matchingCount","totalCount","d","boostTerm","text","SPACE_OR_PUNCTUATION","source","async","ms","LRUCache","cache","first","emit","__emit","shallowRef","resultsEl","searchIndexData","vitePressData","useData","immediate","focusTrapOptions","hasFocus","isPaused","opts","targets","computed","_targets","toValue","toArray","_el","unrefElement","notNullish","watch","els","flush","tryOnScopeDispose","useFocusTrap","localeIndex","theme","searchIndex","computedAsync","markRaw","default","title","titles","provider","filterText","disableQueryPersistence","ref","useSessionStorage","showDetailedList","useLocalStorage","detailedView","disableDetailedView","buttonText","algolia","locales","translations","button","watchEffect","enableNoResults","debouncedWatch","filterTextValue","showDetailedListValue","old","onCleanup","canceled","mods","all","file","pathToFile","mod","fetchExcerpt","mapId","comp","render","setup","app","createApp","warnHandler","provide","dataSymbol","globalProperties","$frontmatter","frontmatter","$params","page","div","mount","anchor","html","nextElementSibling","outerHTML","unmount","nextTick","escapeRegExp","formMarkRegex","excerpts","excerpt","scrollIntoView","block","firstElementChild","debounce","searchInput","disableReset","focusSearchInput","onMounted","selectedIndex","disableMouseOver","scrollToSelectedResult","selectedEl","onKeyStroke","router","useRouter","isComposing","HTMLButtonElement","selectedPackage","HTMLInputElement","go","translate","createSearchTranslate","modal","displayDetails","resetButtonTitle","backButtonTitle","noResultsText","footer","selectText","selectKeyAriaLabel","navigateText","navigateUpKeyAriaLabel","navigateDownKeyAriaLabel","closeText","closeKeyAriaLabel","history","pushState","useEventListener","isLocked","useScrollLock","inBrowser","body","resetSearch","onMouseMove","closest","dataset","onBeforeUnmount","_createBlock","_Teleport","to","_createElementVNode","role","class","onClick","$emit","_hoisted_2","onPointerup","_cache","$event","pointerType","onSubmit","for","_hoisted_4","_unref","autocapitalize","autocomplete","autocorrect","enterkeyhint","maxlength","placeholder","spellcheck","_hoisted_7","_createElementBlock","_normalizeClass","onMousemove","_openBlock","_Fragment","_renderList","p","selected","onMouseenter","onFocusin","_hoisted_13","innerHTML","_hoisted_15","_hoisted_17","_hoisted_18","_hoisted_20","_createTextVNode","_toDisplayString","_hoisted_21","_hoisted_25"],"ignoreList":[1,2,3,4,5,6,7,8,9],"sources":["../../../../../../../../../../@localSearchIndex","../../../../../node_modules/tabbable/dist/index.esm.js","../../../../../node_modules/focus-trap/dist/focus-trap.esm.js","../../../../../node_modules/mark.js/src/lib/domiterator.js","../../../../../node_modules/mark.js/src/lib/mark.js","../../../../../node_modules/mark.js/src/vanilla.js","../../../../../node_modules/minisearch/dist/es/index.js","../../../../../node_modules/vitepress/dist/client/theme-default/support/lru.js","../../../../../node_modules/vitepress/dist/client/theme-default/components/VPLocalSearchBox.vue","../../../../../node_modules/@vueuse/integrations/useFocusTrap.mjs"],"sourcesContent":["export default {\"root\": () => import('@localSearchIndexroot')}","/*!\n* tabbable 6.3.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar _isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && _isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (_isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (_isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = _getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  if (displayCheck === 'full-native') {\n    if ('checkVisibility' in node) {\n      // Chrome >= 105, Edge >= 105, Firefox >= 106, Safari >= 17.4\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/checkVisibility#browser_compatibility\n      var visible = node.checkVisibility({\n        // Checking opacity might be desirable for some use cases, but natively,\n        // opacity zero elements _are_ focusable and tabbable.\n        checkOpacity: false,\n        opacityProperty: false,\n        contentVisibilityAuto: true,\n        visibilityProperty: true,\n        // This is an alias for `visibilityProperty`. Contemporary browsers\n        // support both. However, this alias has wider browser support (Chrome\n        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so\n        // we include it anyway.\n        checkVisibilityCSS: true\n      });\n      return !visible;\n    }\n    // Fall through to manual visibility checks\n  }\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' ||\n  // full-native can run this branch when it falls through in case\n  // Element#checkVisibility is unsupported\n  displayCheck === 'full-native' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  _isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isShadowRootTabbable = function isShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar _sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? _sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = _getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return _sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = _getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.6.6\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, getTabIndex, isFocusable } from 'tabbable';\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap._setPausedState(true);\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {\n      trapStack[trapStack.length - 1]._setPausedState(false);\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    manuallyPaused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || (// fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @param {Object} options\n   * @param {boolean} [options.hasFallback] True if the option could be a selector string\n   *  and the option allows for a fallback scenario in the case where the selector is\n   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).\n   * @param {Array} [options.params] Params to pass to the option if it's a function.\n   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `null` if the option didn't resolve\n   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`\n   *  (node explicitly not given); otherwise, the resolved DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$hasFallback = _ref2.hasFallback,\n      hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback,\n      _ref2$params = _ref2.params,\n      params = _ref2$params === void 0 ? [] : _ref2$params;\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue.apply(void 0, _toConsumableArray(params));\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      try {\n        node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      } catch (err) {\n        throw new Error(\"`\".concat(optionName, \"` appears to be an invalid selector; error=\\\"\").concat(err.message, \"\\\"\"));\n      }\n      if (!node) {\n        if (!hasFallback) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n        // else, `node` MUST be `null` because that's what `Document.querySelector()` returns\n        //  if the selector is valid but doesn't match anything\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus', {\n      hasFallback: true\n    });\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || node && !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    } else if (node === null) {\n      // option is a VALID selector string that doesn't yield a node: use the `fallbackFocus`\n      //  option instead of the default behavior when the option isn't specified at all\n      node = getNodeForOption('fallbackFocus');\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', {\n      params: [previousActiveElement]\n    });\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref3) {\n    var target = _ref3.target,\n      event = _ref3.event,\n      _ref3$isBackward = _ref3.isBackward,\n      isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = state.tabbableGroups.findIndex(function (_ref4) {\n          var firstTabbableNode = _ref4.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = state.tabbableGroups.findIndex(function (_ref5) {\n          var lastTabbableNode = _ref5.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = _getActiveElement(doc);\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = true;\n      return this._setPausedState(true, pauseOptions);\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = false;\n      if (trapStack[trapStack.length - 1] !== this) {\n        return this;\n      }\n      return this._setPausedState(false, unpauseOptions);\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n  Object.defineProperties(trap, {\n    _isManuallyPaused: {\n      value: function value() {\n        return state.manuallyPaused;\n      }\n    },\n    _setPausedState: {\n      value: function value(paused, options) {\n        if (state.paused === paused) {\n          return this;\n        }\n        state.paused = paused;\n        if (paused) {\n          var onPause = getOption(options, 'onPause');\n          var onPostPause = getOption(options, 'onPostPause');\n          onPause === null || onPause === void 0 || onPause();\n          removeListeners();\n          updateObservedNodes();\n          onPostPause === null || onPostPause === void 0 || onPostPause();\n        } else {\n          var onUnpause = getOption(options, 'onUnpause');\n          var onPostUnpause = getOption(options, 'onPostUnpause');\n          onUnpause === null || onUnpause === void 0 || onUnpause();\n          updateTabbableNodes();\n          addListeners();\n          updateObservedNodes();\n          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n        }\n        return this;\n      }\n    }\n  });\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","/**\n * A NodeIterator with iframes support and a method to check if an element is\n * matching a specified selector\n * @example\n * const iterator = new DOMIterator(\n *     document.querySelector(\"#context\"), true\n * );\n * iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n *     console.log(node);\n * }, node => {\n *     if(DOMIterator.matches(node.parentNode, \".ignore\")){\n *         return NodeFilter.FILTER_REJECT;\n *     } else {\n *         return NodeFilter.FILTER_ACCEPT;\n *     }\n * }, () => {\n *     console.log(\"DONE\");\n * });\n * @todo Outsource into separate repository\n */\nexport default class DOMIterator {\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   * @param {boolean} [iframes=true] - A boolean indicating if iframes should\n   * be handled\n   * @param {string[]} [exclude=[]] - An array containing exclusion selectors\n   * for iframes\n   * @param {number} [iframesTimeout=5000] - A number indicating the ms to\n   * wait before an iframe should be skipped, in case the load event isn't\n   * fired. This also applies if the user is offline and the resource of the\n   * iframe is online (either by the browsers \"offline\" mode or because\n   * there's no internet connection)\n   */\n  constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Boolean indicating if iframe support is enabled\n     * @type {boolean}\n     * @access protected\n     */\n    this.iframes = iframes;\n    /**\n     * An array containing exclusion selectors for iframes\n     * @type {string[]}\n     */\n    this.exclude = exclude;\n    /**\n     * The maximum ms to wait for a load event before skipping an iframe\n     * @type {number}\n     */\n    this.iframesTimeout = iframesTimeout;\n  }\n\n  /**\n   * Checks if the specified DOM element matches the selector\n   * @param  {HTMLElement} element - The DOM element\n   * @param  {string|string[]} selector - The selector or an array with\n   * selectors\n   * @return {boolean}\n   * @access public\n   */\n  static matches(element, selector) {\n    const selectors = typeof selector === 'string' ? [selector] : selector,\n      fn = (\n        element.matches ||\n        element.matchesSelector ||\n        element.msMatchesSelector ||\n        element.mozMatchesSelector ||\n        element.oMatchesSelector ||\n        element.webkitMatchesSelector\n      );\n    if (fn) {\n      let match = false;\n      selectors.every(sel => {\n        if (fn.call(element, sel)) {\n          match = true;\n          return false;\n        }\n        return true;\n      });\n      return match;\n    } else { // may be false e.g. when el is a textNode\n      return false;\n    }\n  }\n\n  /**\n   * Returns all contexts filtered by duplicates (even nested)\n   * @return {HTMLElement[]} - An array containing DOM contexts\n   * @access protected\n   */\n  getContexts() {\n    let ctx,\n      filteredCtx = [];\n    if (typeof this.ctx === 'undefined' || !this.ctx) { // e.g. null\n      ctx = [];\n    } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n      ctx = Array.prototype.slice.call(this.ctx);\n    } else if (Array.isArray(this.ctx)) {\n      ctx = this.ctx;\n    } else if (typeof this.ctx === 'string') {\n      ctx = Array.prototype.slice.call(\n        document.querySelectorAll(this.ctx)\n      );\n    } else { // e.g. HTMLElement or element inside iframe\n      ctx = [this.ctx];\n    }\n    // filter duplicate text nodes\n    ctx.forEach(ctx => {\n      const isDescendant = filteredCtx.filter(contexts => {\n        return contexts.contains(ctx);\n      }).length > 0;\n      if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n        filteredCtx.push(ctx);\n      }\n    });\n    return filteredCtx;\n  }\n\n  /**\n   * @callback DOMIterator~getIframeContentsSuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Calls the success callback function with the iframe document. If it can't\n   * be accessed it calls the error callback function\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} [errorFn]\n   * @access protected\n   */\n  getIframeContents(ifr, successFn, errorFn = () => {}) {\n    let doc;\n    try {\n      const ifrWin = ifr.contentWindow;\n      doc = ifrWin.document;\n      if (!ifrWin || !doc) { // no permission = null. Undefined in Phantom\n        throw new Error('iframe inaccessible');\n      }\n    } catch (e) {\n      errorFn();\n    }\n    if (doc) {\n      successFn(doc);\n    }\n  }\n\n  /**\n   * Checks if an iframe is empty (if about:blank is the shown page)\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @return {boolean}\n   * @access protected\n   */\n  isIframeBlank(ifr) {\n    const bl = 'about:blank',\n      src = ifr.getAttribute('src').trim(),\n      href = ifr.contentWindow.location.href;\n    return href === bl && src !== bl && src;\n  }\n\n  /**\n   * Observes the onload event of an iframe and calls the success callback or\n   * the error callback if the iframe is inaccessible. If the event isn't\n   * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll\n   * call the error callback too\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} errorFn\n   * @access protected\n   */\n  observeIframeLoad(ifr, successFn, errorFn) {\n    let called = false,\n      tout = null;\n    const listener = () => {\n      if (called) {\n        return;\n      }\n      called = true;\n      clearTimeout(tout);\n      try {\n        if (!this.isIframeBlank(ifr)) {\n          ifr.removeEventListener('load', listener);\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } catch (e) { // isIframeBlank maybe throws throws an error\n        errorFn();\n      }\n    };\n    ifr.addEventListener('load', listener);\n    tout = setTimeout(listener, this.iframesTimeout);\n  }\n\n  /**\n   * Callback when the iframe is ready\n   * @callback DOMIterator~onIframeReadySuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Callback if the iframe can't be accessed\n   * @callback DOMIterator~onIframeReadyErrorCallback\n   */\n  /**\n   * Calls the callback if the specified iframe is ready for DOM access\n   * @param  {HTMLElement} ifr - The iframe DOM element\n   * @param  {DOMIterator~onIframeReadySuccessCallback} successFn - Success\n   * callback\n   * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback\n   * @see {@link http://stackoverflow.com/a/36155560/3894981} for\n   * background information\n   * @access protected\n   */\n  onIframeReady(ifr, successFn, errorFn) {\n    try {\n      if (ifr.contentWindow.document.readyState === 'complete') {\n        if (this.isIframeBlank(ifr)) {\n          this.observeIframeLoad(ifr, successFn, errorFn);\n        } else {\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } else {\n        this.observeIframeLoad(ifr, successFn, errorFn);\n      }\n    } catch (e) { // accessing document failed\n      errorFn();\n    }\n  }\n\n  /**\n   * Callback when all iframes are ready for DOM access\n   * @callback DOMIterator~waitForIframesDoneCallback\n   */\n  /**\n   * Iterates over all iframes and calls the done callback when all of them\n   * are ready for DOM access (including nested ones)\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback\n   */\n  waitForIframes(ctx, done) {\n    let eachCalled = 0;\n    this.forEachIframe(ctx, () => true, ifr => {\n      eachCalled++;\n      this.waitForIframes(ifr.querySelector('html'), () => {\n        if (!(--eachCalled)) {\n          done();\n        }\n      });\n    }, handled => {\n      if (!handled) {\n        done();\n      }\n    });\n  }\n\n  /**\n   * Callback allowing to filter an iframe. Must return true when the element\n   * should remain, otherwise false\n   * @callback DOMIterator~forEachIframeFilterCallback\n   * @param {HTMLElement} iframe - The iframe DOM element\n   */\n  /**\n   * Callback for each iframe content\n   * @callback DOMIterator~forEachIframeEachCallback\n   * @param {HTMLElement} content - The iframe document\n   */\n  /**\n   * Callback if all iframes inside the context were handled\n   * @callback DOMIterator~forEachIframeEndCallback\n   * @param {number} handled - The number of handled iframes (those who\n   * wheren't filtered)\n   */\n  /**\n   * Iterates over all iframes inside the specified context and calls the\n   * callbacks when they're ready. Filters iframes based on the instance\n   * exclusion selectors\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~forEachIframeFilterCallback} filter - Filter callback\n   * @param {DOMIterator~forEachIframeEachCallback} each - Each callback\n   * @param {DOMIterator~forEachIframeEndCallback} [end] - End callback\n   * @access protected\n   */\n  forEachIframe(ctx, filter, each, end = () => {}) {\n    let ifr = ctx.querySelectorAll('iframe'),\n      open = ifr.length,\n      handled = 0;\n    ifr = Array.prototype.slice.call(ifr);\n    const checkEnd = () => {\n      if (--open <= 0) {\n        end(handled);\n      }\n    };\n    if (!open) {\n      checkEnd();\n    }\n    ifr.forEach(ifr => {\n      if (DOMIterator.matches(ifr, this.exclude)) {\n        checkEnd();\n      } else {\n        this.onIframeReady(ifr, con => {\n          if (filter(ifr)) {\n            handled++;\n            each(con);\n          }\n          checkEnd();\n        }, checkEnd);\n      }\n    });\n  }\n\n  /**\n   * Creates a NodeIterator on the specified context\n   * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {DOMIterator~filterCb} filter\n   * @return {NodeIterator}\n   * @access protected\n   */\n  createIterator(ctx, whatToShow, filter) {\n    return document.createNodeIterator(ctx, whatToShow, filter, false);\n  }\n\n  /**\n   * Creates an instance of DOMIterator in an iframe\n   * @param {HTMLDocument} contents - Iframe document\n   * @return {DOMIterator}\n   * @access protected\n   */\n  createInstanceOnIframe(contents) {\n    return new DOMIterator(contents.querySelector('html'), this.iframes);\n  }\n\n  /**\n   * Checks if an iframe occurs between two nodes, more specifically if an\n   * iframe occurs before the specified node and after the specified prevNode\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} ifr - The iframe to check against\n   * @return {boolean}\n   * @access protected\n   */\n  compareNodeIframe(node, prevNode, ifr) {\n    const compCurr = node.compareDocumentPosition(ifr),\n      prev = Node.DOCUMENT_POSITION_PRECEDING;\n    if (compCurr & prev) {\n      if (prevNode !== null) {\n        const compPrev = prevNode.compareDocumentPosition(ifr),\n          after = Node.DOCUMENT_POSITION_FOLLOWING;\n        if (compPrev & after) {\n          return true;\n        }\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @typedef {DOMIterator~getIteratorNodeReturn}\n   * @type {object.<string>}\n   * @property {HTMLElement} prevNode - The previous node or null if there is\n   * no\n   * @property {HTMLElement} node - The current node\n   */\n  /**\n   * Returns the previous and current node of the specified iterator\n   * @param {NodeIterator} itr - The iterator\n   * @return {DOMIterator~getIteratorNodeReturn}\n   * @access protected\n   */\n  getIteratorNode(itr) {\n    const prevNode = itr.previousNode();\n    let node;\n    if (prevNode === null) {\n      node = itr.nextNode();\n    } else {\n      node = itr.nextNode() && itr.nextNode();\n    }\n    return {\n      prevNode,\n      node\n    };\n  }\n\n  /**\n   * An array containing objects. The object key \"val\" contains an iframe\n   * DOM element. The object key \"handled\" contains a boolean indicating if\n   * the iframe was handled already.\n   * It wouldn't be enough to save all open or all already handled iframes.\n   * The information of open iframes is necessary because they may occur after\n   * all other text nodes (and compareNodeIframe would never be true). The\n   * information of already handled iframes is necessary as otherwise they may\n   * be handled multiple times\n   * @typedef DOMIterator~checkIframeFilterIfr\n   * @type {object[]}\n   */\n  /**\n   * Checks if an iframe wasn't handled already and if so, calls\n   * {@link DOMIterator#compareNodeIframe} to check if it should be handled.\n   * Information wheter an iframe was or wasn't handled is given within the\n   * <code>ifr</code> dictionary\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} currIfr - The iframe to check\n   * @param {DOMIterator~checkIframeFilterIfr} ifr - The iframe dictionary.\n   * Will be manipulated (by reference)\n   * @return {boolean} Returns true when it should be handled, otherwise false\n   * @access protected\n   */\n  checkIframeFilter(node, prevNode, currIfr, ifr) {\n    let key = false, // false === doesn't exist\n      handled = false;\n    ifr.forEach((ifrDict, i) => {\n      if (ifrDict.val === currIfr) {\n        key = i;\n        handled = ifrDict.handled;\n      }\n    });\n    if (this.compareNodeIframe(node, prevNode, currIfr)) {\n      if (key === false && !handled) {\n        ifr.push({\n          val: currIfr,\n          handled: true\n        });\n      } else if (key !== false && !handled) {\n        ifr[key].handled = true;\n      }\n      return true;\n    }\n    if (key === false) {\n      ifr.push({\n        val: currIfr,\n        handled: false\n      });\n    }\n    return false;\n  }\n\n  /**\n   * Creates an iterator on all open iframes in the specified array and calls\n   * the end callback when finished\n   * @param {DOMIterator~checkIframeFilterIfr} ifr\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} eCb - Each callback\n   * @param {DOMIterator~filterCb} fCb\n   * @access protected\n   */\n  handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n    ifr.forEach(ifrDict => {\n      if (!ifrDict.handled) {\n        this.getIframeContents(ifrDict.val, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, eCb, fCb\n          );\n        });\n      }\n    });\n  }\n\n  /**\n   * Iterates through all nodes in the specified context and handles iframe\n   * nodes at the correct position\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {HTMLElement} ctx - The context\n   * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback\n   * @param {DOMIterator~filterCb} filterCb - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback\n   * @access protected\n   */\n  iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n    const itr = this.createIterator(ctx, whatToShow, filterCb);\n    let ifr = [],\n      elements = [],\n      node, prevNode, retrieveNodes = () => {\n        ({\n          prevNode,\n          node\n        } = this.getIteratorNode(itr));\n        return node;\n      };\n    while (retrieveNodes()) {\n      if (this.iframes) {\n        this.forEachIframe(ctx, currIfr => {\n          // note that ifr will be manipulated here\n          return this.checkIframeFilter(node, prevNode, currIfr, ifr);\n        }, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, ifrNode => elements.push(ifrNode), filterCb\n          );\n        });\n      }\n      // it's faster to call the each callback in an array loop\n      // than in this while loop\n      elements.push(node);\n    }\n    elements.forEach(node => {\n      eachCb(node);\n    });\n    if (this.iframes) {\n      this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n    }\n    doneCb();\n  }\n\n  /**\n   * Callback for each node\n   * @callback DOMIterator~forEachNodeCallback\n   * @param {HTMLElement} node - The DOM text node element\n   */\n  /**\n   * Callback if all contexts were handled\n   * @callback DOMIterator~forEachNodeEndCallback\n   */\n  /**\n   * Iterates over all contexts and initializes\n   * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} each - Each callback\n   * @param {DOMIterator~filterCb} filter - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} done - End callback\n   * @access public\n   */\n  forEachNode(whatToShow, each, filter, done = () => {}) {\n    const contexts = this.getContexts();\n    let open = contexts.length;\n    if (!open) {\n      done();\n    }\n    contexts.forEach(ctx => {\n      const ready = () => {\n        this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\n          if (--open <= 0) { // call end all contexts were handled\n            done();\n          }\n        });\n      };\n      // wait for iframes to avoid recursive calls, otherwise this would\n      // perhaps reach the recursive function call limit with many nodes\n      if (this.iframes) {\n        this.waitForIframes(ctx, ready);\n      } else {\n        ready();\n      }\n    });\n  }\n\n  /**\n   * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or\n   * NodeFilter.FILTER_REJECT\n   * @see {@link http://tinyurl.com/zdczmm2}\n   * @callback DOMIterator~filterCb\n   * @param {HTMLElement} node - The node to filter\n   */\n  /**\n   * @typedef DOMIterator~whatToShow\n   * @see {@link http://tinyurl.com/zfqqkx2}\n   * @type {number}\n   */\n}\n","import DOMIterator from './domiterator';\n\n/**\n * Marks search terms in DOM elements\n * @example\n * new Mark(document.querySelector(\".context\")).mark(\"lorem ipsum\");\n * @example\n * new Mark(document.querySelector(\".context\")).markRegExp(/lorem/gmi);\n */\nexport default class Mark { // eslint-disable-line no-unused-vars\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   */\n  constructor(ctx) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Specifies if the current browser is a IE (necessary for the node\n     * normalization bug workaround). See {@link Mark#unwrapMatches}\n     * @type {boolean}\n     * @access protected\n     */\n    this.ie = false;\n    const ua = window.navigator.userAgent;\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n      this.ie = true;\n    }\n  }\n\n  /**\n   * Options defined by the user. They will be initialized from one of the\n   * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},\n   * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.\n   * @type {object}\n   * @param {object} [val] - An object that will be merged with defaults\n   * @access protected\n   */\n  set opt(val) {\n    this._opt = Object.assign({}, {\n      'element': '',\n      'className': '',\n      'exclude': [],\n      'iframes': false,\n      'iframesTimeout': 5000,\n      'separateWordSearch': true,\n      'diacritics': true,\n      'synonyms': {},\n      'accuracy': 'partially',\n      'acrossElements': false,\n      'caseSensitive': false,\n      'ignoreJoiners': false,\n      'ignoreGroups': 0,\n      'ignorePunctuation': [],\n      'wildcards': 'disabled',\n      'each': () => {},\n      'noMatch': () => {},\n      'filter': () => true,\n      'done': () => {},\n      'debug': false,\n      'log': window.console\n    }, val);\n  }\n\n  get opt() {\n    return this._opt;\n  }\n\n  /**\n   * An instance of DOMIterator\n   * @type {DOMIterator}\n   * @access protected\n   */\n  get iterator() {\n    // always return new instance in case there were option changes\n    return new DOMIterator(\n      this.ctx,\n      this.opt.iframes,\n      this.opt.exclude,\n      this.opt.iframesTimeout\n    );\n  }\n\n  /**\n   * Logs a message if log is enabled\n   * @param {string} msg - The message to log\n   * @param {string} [level=\"debug\"] - The log level, e.g. <code>warn</code>\n   * <code>error</code>, <code>debug</code>\n   * @access protected\n   */\n  log(msg, level = 'debug') {\n    const log = this.opt.log;\n    if (!this.opt.debug) {\n      return;\n    }\n    if (typeof log === 'object' && typeof log[level] === 'function') {\n      log[level](`mark.js: ${msg}`);\n    }\n  }\n\n  /**\n   * Escapes a string for usage within a regular expression\n   * @param {string} str - The string to escape\n   * @return {string}\n   * @access protected\n   */\n  escapeStr(str) {\n    // eslint-disable-next-line no-useless-escape\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified search\n   * term including synonyms, diacritics and accuracy if defined\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createRegExp(str) {\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.setupWildcardsRegExp(str);\n    }\n    str = this.escapeStr(str);\n    if (Object.keys(this.opt.synonyms).length) {\n      str = this.createSynonymsRegExp(str);\n    }\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    if (this.opt.diacritics) {\n      str = this.createDiacriticsRegExp(str);\n    }\n    str = this.createMergedBlanksRegExp(str);\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.createJoinersRegExp(str);\n    }\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.createWildcardsRegExp(str);\n    }\n    str = this.createAccuracyRegExp(str);\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string to match the defined synonyms\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createSynonymsRegExp(str) {\n    const syn = this.opt.synonyms,\n      sens = this.opt.caseSensitive ? '' : 'i',\n      // add replacement character placeholder before and after the\n      // synonym group\n      joinerPlaceholder = this.opt.ignoreJoiners ||\n                this.opt.ignorePunctuation.length ? '\\u0000' : '';\n    for (let index in syn) {\n      if (syn.hasOwnProperty(index)) {\n        const value = syn[index],\n          k1 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(index) :\n            this.escapeStr(index),\n          k2 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(value) :\n            this.escapeStr(value);\n        if (k1 !== '' && k2 !== '') {\n          str = str.replace(\n            new RegExp(\n              `(${this.escapeStr(k1)}|${this.escapeStr(k2)})`,\n              `gm${sens}`\n            ),\n            joinerPlaceholder +\n            `(${this.processSynomyms(k1)}|` +\n            `${this.processSynomyms(k2)})` +\n            joinerPlaceholder\n          );\n        }\n      }\n    }\n    return str;\n  }\n\n  /**\n   * Setup synonyms to work with ignoreJoiners and or ignorePunctuation\n   * @param {string} str - synonym key or value to process\n   * @return {string} - processed synonym string\n   */\n  processSynomyms(str) {\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    return str;\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupWildcardsRegExp(str) {\n    // replace single character wildcard with unicode 0001\n    str = str.replace(/(?:\\\\)*\\?/g, val => {\n      return val.charAt(0) === '\\\\' ? '?' : '\\u0001';\n    });\n    // replace multiple character wildcard with unicode 0002\n    return str.replace(/(?:\\\\)*\\*/g, val => {\n      return val.charAt(0) === '\\\\' ? '*' : '\\u0002';\n    });\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createWildcardsRegExp(str) {\n    // default to \"enable\" (i.e. to not include spaces)\n    // \"withSpaces\" uses `[\\\\S\\\\s]` instead of `.` because the latter\n    // does not match new line characters\n    let spaces = this.opt.wildcards === 'withSpaces';\n    return str\n    // replace unicode 0001 with a RegExp class to match any single\n    // character, or any single non-whitespace character depending\n    // on the setting\n      .replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?')\n    // replace unicode 0002 with a RegExp class to match zero or\n    // more characters, or zero or more non-whitespace characters\n    // depending on the setting\n      .replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * designated characters (soft hyphens & zero width characters)\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupIgnoreJoinersRegExp(str) {\n    // adding a \"null\" unicode character as it will not be modified by the\n    // other \"create\" regular expression functions\n    return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\n      // don't add a null after an opening \"(\", around a \"|\" or before\n      // a closing \"(\", or between an escapement (e.g. \\+)\n      let nextChar = original.charAt(indx + 1);\n      if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n        return val;\n      } else {\n        return val + '\\u0000';\n      }\n    });\n  }\n\n  /**\n   * Creates a regular expression string to allow ignoring of designated\n   * characters (soft hyphens, zero width characters & punctuation) based on\n   * the specified option values of <code>ignorePunctuation</code> and\n   * <code>ignoreJoiners</code>\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createJoinersRegExp(str) {\n    let joiner = [];\n    const ignorePunctuation = this.opt.ignorePunctuation;\n    if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n      joiner.push(this.escapeStr(ignorePunctuation.join('')));\n    }\n    if (this.opt.ignoreJoiners) {\n      // u+00ad = soft hyphen\n      // u+200b = zero-width space\n      // u+200c = zero-width non-joiner\n      // u+200d = zero-width joiner\n      joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\n    }\n    return joiner.length ?\n      str.split(/\\u0000+/).join(`[${joiner.join('')}]*`) :\n      str;\n  }\n\n  /**\n   * Creates a regular expression string to match diacritics\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createDiacriticsRegExp(str) {\n    const sens = this.opt.caseSensitive ? '' : 'i',\n      dct = this.opt.caseSensitive ? [\n        'a', 'A',\n        'c', 'C', 'd', 'D',\n        'e', 'E',\n        'i', 'I', 'l', 'L', 'n',\n        'N', 'o', 'O',\n        'r', 'R', 's', 'S',\n        't', 'T', 'u', 'U',\n        'y', 'Y', 'z', 'Z'\n      ] : [\n        'aA', 'cC',\n        'dD', 'eE',\n        'iI', 'lL', 'nN',\n        'oO', 'rR',\n        'sS', 'tT',\n        'uU', 'yY', 'zZ'\n      ];\n    let handled = [];\n    str.split('').forEach(ch => {\n      dct.every(dct => {\n        // Check if the character is inside a diacritics list\n        if (dct.indexOf(ch) !== -1) {\n          // Check if the related diacritics list was not\n          // handled yet\n          if (handled.indexOf(dct) > -1) {\n            return false;\n          }\n          // Make sure that the character OR any other\n          // character in the diacritics list will be matched\n          str = str.replace(\n            new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`\n          );\n          handled.push(dct);\n        }\n        return true;\n      });\n    });\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string that merges whitespace characters\n   * including subsequent ones into a single pattern, one or multiple\n   * whitespaces\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createMergedBlanksRegExp(str) {\n    return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified string with\n   * the defined accuracy. As in the regular expression of \"exactly\" can be\n   * a group containing a blank at the beginning, all regular expressions will\n   * be created with two groups. The first group can be ignored (may contain\n   * the said blank), the second contains the actual match\n   * @param  {string} str - The searm term to be used\n   * @return {str}\n   * @access protected\n   */\n  createAccuracyRegExp(str) {\n    const chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~';\n    let acc = this.opt.accuracy,\n      val = typeof acc === 'string' ? acc : acc.value,\n      ls = typeof acc === 'string' ? [] : acc.limiters,\n      lsJoin = '';\n    ls.forEach(limiter => {\n      lsJoin += `|${this.escapeStr(limiter)}`;\n    });\n    switch (val) {\n    case 'partially':\n    default:\n      return `()(${str})`;\n    case 'complementary':\n      lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n      return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\n    case 'exactly':\n      return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\n    }\n  }\n\n  /**\n   * @typedef Mark~separatedKeywords\n   * @type {object.<string>}\n   * @property {array.<string>} keywords - The list of keywords\n   * @property {number} length - The length\n   */\n  /**\n   * Returns a list of keywords dependent on whether separate word search\n   * was defined. Also it filters empty keywords\n   * @param {array} sv - The array of keywords\n   * @return {Mark~separatedKeywords}\n   * @access protected\n   */\n  getSeparatedKeywords(sv) {\n    let stack = [];\n    sv.forEach(kw => {\n      if (!this.opt.separateWordSearch) {\n        if (kw.trim() && stack.indexOf(kw) === -1) {\n          stack.push(kw);\n        }\n      } else {\n        kw.split(' ').forEach(kwSplitted => {\n          if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n            stack.push(kwSplitted);\n          }\n        });\n      }\n    });\n    return {\n      // sort because of https://git.io/v6USg\n      'keywords': stack.sort((a, b) => {\n        return b.length - a.length;\n      }),\n      'length': stack.length\n    };\n  }\n\n  /**\n   * Check if a value is a number\n   * @param {number|string} value - the value to check;\n   * numeric strings allowed\n   * @return {boolean}\n   * @access protected\n   */\n  isNumeric(value) {\n    // http://stackoverflow.com/a/16655847/145346\n    // eslint-disable-next-line eqeqeq\n    return Number(parseFloat(value)) == value;\n  }\n\n  /**\n   * @typedef Mark~rangeObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} length - The length of the string to mark within the\n   * composite value.\n   */\n  /**\n   * @typedef Mark~setOfRanges\n   * @type {object[]}\n   * @property {Mark~rangeObject}\n   */\n  /**\n   * Returns a processed list of integer offset indexes that do not overlap\n   * each other, and remove any string values or additional elements\n   * @param {Mark~setOfRanges} array - unprocessed raw array\n   * @return {Mark~setOfRanges} - processed array with any invalid entries\n   * removed\n   * @throws Will throw an error if an array of objects is not passed\n   * @access protected\n   */\n  checkRanges(array) {\n    // start and length indexes are included in an array of objects\n    // [{start: 0, length: 1}, {start: 4, length: 5}]\n    // quick validity check of the first entry only\n    if (\n      !Array.isArray(array) ||\n      Object.prototype.toString.call( array[0] ) !== '[object Object]'\n    ) {\n      this.log('markRanges() will only accept an array of objects');\n      this.opt.noMatch(array);\n      return [];\n    }\n    const stack = [];\n    let last = 0;\n    array\n    // acending sort to ensure there is no overlap in start & end\n    // offsets\n      .sort((a, b) => {\n        return a.start - b.start;\n      })\n      .forEach(item => {\n        let {start, end, valid} = this.callNoMatchOnInvalidRanges(item, last);\n        if (valid) {\n          // preserve item in case there are extra key:values within\n          item.start = start;\n          item.length = end - start;\n          stack.push(item);\n          last = end;\n        }\n      });\n    return stack;\n  }\n\n  /**\n   * @typedef Mark~validObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} end - The calculated end position within the composite\n   * value.\n   * @property {boolean} valid - boolean value indicating that the start and\n   * calculated end range is valid\n   */\n  /**\n    * Initial validation of ranges for markRanges. Preliminary checks are done\n    * to ensure the start and length values exist and are not zero or non-\n    * numeric\n    * @param {Mark~rangeObject} range - the current range object\n    * @param {number} last - last index of range\n    * @return {Mark~validObject}\n    * @access protected\n    */\n  callNoMatchOnInvalidRanges(range, last) {\n    let start, end,\n      valid = false;\n    if (range && typeof range.start !== 'undefined') {\n      start = parseInt(range.start, 10);\n      end = start + parseInt(range.length, 10);\n      // ignore overlapping values & non-numeric entries\n      if (\n        this.isNumeric(range.start) &&\n        this.isNumeric(range.length) &&\n        end - last > 0 &&\n        end - start > 0\n      ) {\n        valid = true;\n      } else {\n        this.log(\n          'Ignoring invalid or overlapping range: ' +\n                    `${JSON.stringify(range)}`\n        );\n        this.opt.noMatch(range);\n      }\n    } else {\n      this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * Check valid range for markRanges. Check ranges with access to the context\n   * string. Range values are double checked, lengths that extend the mark\n   * beyond the string length are limitied and ranges containing only\n   * whitespace are ignored\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {number} originalLength - original length of the context string\n   * @param {string} string - current content string\n   * @return {Mark~validObject}\n   * @access protected\n   */\n  checkWhitespaceRanges(range, originalLength, string) {\n    let end,\n      valid = true,\n      // the max value changes after the DOM is manipulated\n      max = string.length,\n      // adjust offset to account for wrapped text node\n      offset = originalLength - max,\n      start = parseInt(range.start, 10) - offset;\n    // make sure to stop at max\n    start = start > max ? max : start;\n    end = start + parseInt(range.length, 10);\n    if (end > max) {\n      end = max;\n      this.log(`End range automatically set to the max value of ${max}`);\n    }\n    if (start < 0 || end - start < 0 || start > max || end > max) {\n      valid = false;\n      this.log(`Invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n      valid = false;\n      // whitespace only; even if wrapped it is not visible\n      this.log('Skipping whitespace only range: ' +JSON.stringify(range));\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * @typedef Mark~getTextNodesDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Callback\n   * @callback Mark~getTextNodesCallback\n   * @param {Mark~getTextNodesDict}\n   */\n  /**\n   * Calls the callback with an object containing all text nodes (including\n   * iframe text nodes) with start and end positions and the composite value\n   * of them (string)\n   * @param {Mark~getTextNodesCallback} cb - Callback\n   * @access protected\n   */\n  getTextNodes(cb) {\n    let val = '',\n      nodes = [];\n    this.iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n      nodes.push({\n        start: val.length,\n        end: (val += node.textContent).length,\n        node\n      });\n    }, node => {\n      if (this.matchesExclude(node.parentNode)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, () => {\n      cb({\n        value: val,\n        nodes: nodes\n      });\n    });\n  }\n\n  /**\n   * Checks if an element matches any of the specified exclude selectors. Also\n   * it checks for elements in which no marks should be performed (e.g.\n   * script and style tags) and optionally already marked elements\n   * @param  {HTMLElement} el - The element to check\n   * @return {boolean}\n   * @access protected\n   */\n  matchesExclude(el) {\n    return DOMIterator.matches(el, this.opt.exclude.concat([\n      // ignores the elements itself, not their childrens (selector *)\n      'script', 'style', 'title', 'head', 'html'\n    ]));\n  }\n\n  /**\n   * Wraps the instance element and class around matches that fit the start\n   * and end positions within the node\n   * @param  {HTMLElement} node - The DOM text node\n   * @param  {number} start - The position where to start wrapping\n   * @param  {number} end - The position where to end wrapping\n   * @return {HTMLElement} Returns the splitted text node that will appear\n   * after the wrapped text node\n   * @access protected\n   */\n  wrapRangeInTextNode(node, start, end) {\n    const hEl = !this.opt.element ? 'mark' : this.opt.element,\n      startNode = node.splitText(start),\n      ret = startNode.splitText(end - start);\n    let repl = document.createElement(hEl);\n    repl.setAttribute('data-markjs', 'true');\n    if (this.opt.className) {\n      repl.setAttribute('class', this.opt.className);\n    }\n    repl.textContent = startNode.textContent;\n    startNode.parentNode.replaceChild(repl, startNode);\n    return ret;\n  }\n\n  /**\n   * @typedef Mark~wrapRangeInMappedTextNodeDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Each callback\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} node - The wrapped DOM element\n   * @param {number} lastIndex - The last matching position within the\n   * composite value of text nodes\n   */\n  /**\n   * Filter callback\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {HTMLElement} node - The matching text node DOM element\n   */\n  /**\n   * Determines matches by start and end positions using the text node\n   * dictionary even across text nodes and calls\n   * {@link Mark#wrapRangeInTextNode} to wrap them\n   * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary\n   * @param  {number} start - The start position of the match\n   * @param  {number} end - The end position of the match\n   * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback\n   * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback\n   * @access protected\n   */\n  wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n    // iterate over all text nodes to find the one matching the positions\n    dict.nodes.every((n, i) => {\n      const sibl = dict.nodes[i + 1];\n      if (typeof sibl === 'undefined' || sibl.start > start) {\n        if (!filterCb(n.node)) {\n          return false;\n        }\n        // map range from dict.value to text node\n        const s = start - n.start,\n          e = (end > n.end ? n.end : end) - n.start,\n          startStr = dict.value.substr(0, n.start),\n          endStr = dict.value.substr(e + n.start);\n        n.node = this.wrapRangeInTextNode(n.node, s, e);\n        // recalculate positions to also find subsequent matches in the\n        // same text node. Necessary as the text node in dict now only\n        // contains the splitted part after the wrapped one\n        dict.value = startStr + endStr;\n        dict.nodes.forEach((k, j) => {\n          if (j >= i) {\n            if (dict.nodes[j].start > 0 && j !== i) {\n              dict.nodes[j].start -= e;\n            }\n            dict.nodes[j].end -= e;\n          }\n        });\n        end -= e;\n        eachCb(n.node.previousSibling, n.start);\n        if (end > n.end) {\n          start = n.end;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches within single HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesFilterCallback} filterCb\n   * @param {Mark~wrapMatchesEachCallback} eachCb\n   * @param {Mark~wrapMatchesEndCallback} endCb\n   * @access protected\n   */\n  wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      dict.nodes.forEach(node => {\n        node = node.node;\n        let match;\n        while (\n          (match = regex.exec(node.textContent)) !== null &&\n          match[matchIdx] !== ''\n        ) {\n          if (!filterCb(match[matchIdx], node)) {\n            continue;\n          }\n          let pos = match.index;\n          if (matchIdx !== 0) {\n            for (let i = 1; i < matchIdx; i++) {\n              pos += match[i].length;\n            }\n          }\n          node = this.wrapRangeInTextNode(\n            node,\n            pos,\n            pos + match[matchIdx].length\n          );\n          eachCb(node.previousSibling);\n          // reset index of last match as the node changed and the\n          // index isn't valid anymore http://tinyurl.com/htsudjd\n          regex.lastIndex = 0;\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesAcrossElementsEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesAcrossElementsFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesAcrossElementsEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches across all HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb\n   * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb\n   * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb\n   * @access protected\n   */\n  wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      let match;\n      while (\n        (match = regex.exec(dict.value)) !== null &&\n        match[matchIdx] !== ''\n      ) {\n        // calculate range inside dict.value\n        let start = match.index;\n        if (matchIdx !== 0) {\n          for (let i = 1; i < matchIdx; i++) {\n            start += match[i].length;\n          }\n        }\n        const end = start + match[matchIdx].length;\n        // note that dict will be updated automatically, as it'll change\n        // in the wrapping process, due to the fact that text\n        // nodes will be splitted\n        this.wrapRangeInMappedTextNode(dict, start, end, node => {\n          return filterCb(match[matchIdx], node);\n        }, (node, lastIndex) => {\n          regex.lastIndex = lastIndex;\n          eachCb(node);\n        });\n      }\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapRangeFromIndexEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {Mark~rangeObject} range - the current range object; provided\n   * start and length values will be numeric integers modified from the\n   * provided original ranges.\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapRangeFromIndexFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapRangeFromIndexEndCallback\n   */\n  /**\n   * Wraps the indicated ranges across all HTML elements in all contexts\n   * @param {Mark~setOfRanges} ranges\n   * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb\n   * @param {Mark~wrapRangeFromIndexEachCallback} eachCb\n   * @param {Mark~wrapRangeFromIndexEndCallback} endCb\n   * @access protected\n   */\n  wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n    this.getTextNodes(dict => {\n      const originalLength = dict.value.length;\n      ranges.forEach((range, counter) => {\n        let {start, end, valid} = this.checkWhitespaceRanges(\n          range,\n          originalLength,\n          dict.value\n        );\n        if (valid) {\n          this.wrapRangeInMappedTextNode(dict, start, end, node => {\n            return filterCb(\n              node,\n              range,\n              dict.value.substring(start, end),\n              counter\n            );\n          }, node => {\n            eachCb(node, range);\n          });\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Unwraps the specified DOM node with its content (text nodes or HTML)\n   * without destroying possibly present events (using innerHTML) and\n   * normalizes the parent at the end (merge splitted text nodes)\n   * @param  {HTMLElement} node - The DOM node to unwrap\n   * @access protected\n   */\n  unwrapMatches(node) {\n    const parent = node.parentNode;\n    let docFrag = document.createDocumentFragment();\n    while (node.firstChild) {\n      docFrag.appendChild(node.removeChild(node.firstChild));\n    }\n    parent.replaceChild(docFrag, node);\n    if (!this.ie) { // use browser's normalize method\n      parent.normalize();\n    } else { // custom method (needs more time)\n      this.normalizeTextNode(parent);\n    }\n  }\n\n  /**\n   * Normalizes text nodes. It's a workaround for the native normalize method\n   * that has a bug in IE (see attached link). Should only be used in IE\n   * browsers as it's slower than the native method.\n   * @see {@link http://tinyurl.com/z5asa8c}\n   * @param {HTMLElement} node - The DOM node to normalize\n   * @access protected\n   */\n  normalizeTextNode(node) {\n    if (!node) {\n      return;\n    }\n    if (node.nodeType === 3) {\n      while (node.nextSibling && node.nextSibling.nodeType === 3) {\n        node.nodeValue += node.nextSibling.nodeValue;\n        node.parentNode.removeChild(node.nextSibling);\n      }\n    } else {\n      this.normalizeTextNode(node.firstChild);\n    }\n    this.normalizeTextNode(node.nextSibling);\n  }\n\n  /**\n   * Callback when finished\n   * @callback Mark~commonDoneCallback\n   * @param {number} totalMatches - The number of marked elements\n   */\n  /**\n   * @typedef Mark~commonOptions\n   * @type {object.<string>}\n   * @property {string} [element=\"mark\"] - HTML element tag name\n   * @property {string} [className] - An optional class name\n   * @property {string[]} [exclude] - An array with exclusion selectors.\n   * Elements matching those selectors will be ignored\n   * @property {boolean} [iframes=false] - Whether to search inside iframes\n   * @property {Mark~commonDoneCallback} [done]\n   * @property {boolean} [debug=false] - Wheter to log messages\n   * @property {object} [log=window.console] - Where to log messages (only if\n   * debug is true)\n   */\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRegExpEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markRegExpNoMatchCallback\n   * @param {RegExp} regexp - The regular expression\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRegExpFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching string for the RegExp\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRegExpOptions\n   * @type {object.<string>}\n   * @property {Mark~markRegExpEachCallback} [each]\n   * @property {Mark~markRegExpNoMatchCallback} [noMatch]\n   * @property {Mark~markRegExpFilterCallback} [filter]\n   */\n  /**\n   * Marks a custom regular expression\n   * @param  {RegExp} regexp - The regular expression\n   * @param  {Mark~markRegExpOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRegExp(regexp, opt) {\n    this.opt = opt;\n    this.log(`Searching with expression \"${regexp}\"`);\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n    const eachCb = element => {\n      totalMatches++;\n      this.opt.each(element);\n    };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    this[fn](regexp, this.opt.ignoreGroups, (match, node) => {\n      return this.opt.filter(node, match, totalMatches);\n    }, eachCb, () => {\n      if (totalMatches === 0) {\n        this.opt.noMatch(regexp);\n      }\n      this.opt.done(totalMatches);\n    });\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markNoMatchCallback\n   * @param {RegExp} term - The search term that was not found\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching term\n   * @param {number} totalCounter - A counter indicating the number of all\n   * marks\n   * @param {number} termCounter - A counter indicating the number of marks\n   * for the specific match\n   */\n  /**\n   * @typedef Mark~markAccuracyObject\n   * @type {object.<string>}\n   * @property {string} value - A accuracy string value\n   * @property {string[]} limiters - A custom array of limiters. For example\n   * <code>[\"-\", \",\"]</code>\n   */\n  /**\n   * @typedef Mark~markAccuracySetting\n   * @type {string}\n   * @property {\"partially\"|\"complementary\"|\"exactly\"|Mark~markAccuracyObject}\n   * [accuracy=\"partially\"] - Either one of the following string values:\n   * <ul>\n   *   <li><i>partially</i>: When searching for \"lor\" only \"lor\" inside\n   *   \"lorem\" will be marked</li>\n   *   <li><i>complementary</i>: When searching for \"lor\" the whole word\n   *   \"lorem\" will be marked</li>\n   *   <li><i>exactly</i>: When searching for \"lor\" only those exact words\n   *   will be marked. In this example nothing inside \"lorem\". This value\n   *   is equivalent to the previous option <i>wordBoundary</i></li>\n   * </ul>\n   * Or an object containing two properties:\n   * <ul>\n   *   <li><i>value</i>: One of the above named string values</li>\n   *   <li><i>limiters</i>: A custom array of string limiters for accuracy\n   *   \"exactly\" or \"complementary\"</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markWildcardsSetting\n   * @type {string}\n   * @property {\"disabled\"|\"enabled\"|\"withSpaces\"}\n   * [wildcards=\"disabled\"] - Set to any of the following string values:\n   * <ul>\n   *   <li><i>disabled</i>: Disable wildcard usage</li>\n   *   <li><i>enabled</i>: When searching for \"lor?m\", the \"?\" will match zero\n   *   or one non-space character (e.g. \"lorm\", \"loram\", \"lor3m\", etc). When\n   *   searching for \"lor*m\", the \"*\" will match zero or more non-space\n   *   characters (e.g. \"lorm\", \"loram\", \"lor123m\", etc).</li>\n   *   <li><i>withSpaces</i>: When searching for \"lor?m\", the \"?\" will\n   *   match zero or one space or non-space character (e.g. \"lor m\", \"loram\",\n   *   etc). When searching for \"lor*m\", the \"*\" will match zero or more space\n   *   or non-space characters (e.g. \"lorm\", \"lore et dolor ipsum\", \"lor: m\",\n   *   etc).</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markIgnorePunctuationSetting\n   * @type {string[]}\n   * @property {string} The strings in this setting will contain punctuation\n   * marks that will be ignored:\n   * <ul>\n   *   <li>These punctuation marks can be between any characters, e.g. setting\n   *   this option to <code>[\"'\"]</code> would match \"Worlds\", \"World's\" and\n   *   \"Wo'rlds\"</li>\n   *   <li>One or more apostrophes between the letters would still produce a\n   *   match (e.g. \"W'o''r'l'd's\").</li>\n   *   <li>A typical setting for this option could be as follows:\n   *   <pre>ignorePunctuation: \":;.,-_(){}[]!'\\\"+=\".split(\"\"),</pre> This\n   *   setting includes common punctuation as well as a minus, en-dash,\n   *   em-dash and figure-dash\n   *   ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well\n   *   as an underscore.</li>\n   * </ul>\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markOptions\n   * @type {object.<string>}\n   * @property {boolean} [separateWordSearch=true] - Whether to search for\n   * each word separated by a blank instead of the complete term\n   * @property {boolean} [diacritics=true] - If diacritic characters should be\n   * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics})\n   * @property {object} [synonyms] - An object with synonyms. The key will be\n   * a synonym for the value and the value for the key\n   * @property {Mark~markAccuracySetting} [accuracy]\n   * @property {Mark~markWildcardsSetting} [wildcards]\n   * @property {boolean} [acrossElements=false] - Whether to find matches\n   * across HTML elements. By default, only matches within single HTML\n   * elements will be found\n   * @property {boolean} [ignoreJoiners=false] - Whether to ignore word\n   * joiners inside of key words. These include soft-hyphens, zero-width\n   * space, zero-width non-joiners and zero-width joiners.\n   * @property {Mark~markIgnorePunctuationSetting} [ignorePunctuation]\n   * @property {Mark~markEachCallback} [each]\n   * @property {Mark~markNoMatchCallback} [noMatch]\n   * @property {Mark~markFilterCallback} [filter]\n   */\n  /**\n   * Marks the specified search terms\n   * @param {string|string[]} [sv] - Search value, either a search string or\n   * an array containing multiple search strings\n   * @param  {Mark~markOptions} [opt] - Optional options object\n   * @access public\n   */\n  mark(sv, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n\n    const {\n        keywords: kwArr,\n        length: kwArrLen\n      } = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n      sens = this.opt.caseSensitive ? '' : 'i',\n      handler = kw => { // async function calls as iframes are async too\n        let regex = new RegExp(this.createRegExp(kw), `gm${sens}`),\n          matches = 0;\n        this.log(`Searching with expression \"${regex}\"`);\n        this[fn](regex, 1, (term, node) => {\n          return this.opt.filter(node, kw, totalMatches, matches);\n        }, element => {\n          matches++;\n          totalMatches++;\n          this.opt.each(element);\n        }, () => {\n          if (matches === 0) {\n            this.opt.noMatch(kw);\n          }\n          if (kwArr[kwArrLen - 1] === kw) {\n            this.opt.done(totalMatches);\n          } else {\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\n          }\n        });\n      };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    if (kwArrLen === 0) {\n      this.opt.done(totalMatches);\n    } else {\n      handler(kwArr[0]);\n    }\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRangesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {array} range - array of range start and end points\n   */\n  /**\n   * Callback if a processed range is invalid, out-of-bounds, overlaps another\n   * range, or only matches whitespace\n   * @callback Mark~markRangesNoMatchCallback\n   * @param {Mark~rangeObject} range - a range object\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRangesFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {array} range - array of range start and end points\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRangesOptions\n   * @type {object.<string>}\n   * @property {Mark~markRangesEachCallback} [each]\n   * @property {Mark~markRangesNoMatchCallback} [noMatch]\n   * @property {Mark~markRangesFilterCallback} [filter]\n   */\n  /**\n   * Marks an array of objects containing a start with an end or length of the\n   * string to mark\n   * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)\n   * array of objects\n   * @param  {Mark~markRangesOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRanges(rawRanges, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      ranges = this.checkRanges(rawRanges);\n    if (ranges && ranges.length) {\n      this.log(\n        'Starting to mark with the following ranges: ' +\n        JSON.stringify(ranges)\n      );\n      this.wrapRangeFromIndex(\n        ranges, (node, range, match, counter) => {\n          return this.opt.filter(node, range, match, counter);\n        }, (element, range) => {\n          totalMatches++;\n          this.opt.each(element, range);\n        }, () => {\n          this.opt.done(totalMatches);\n        }\n      );\n    } else {\n      this.opt.done(totalMatches);\n    }\n  }\n\n  /**\n   * Removes all marked elements inside the context with their HTML and\n   * normalizes the parent at the end\n   * @param  {Mark~commonOptions} [opt] - Optional options object\n   * @access public\n   */\n  unmark(opt) {\n    this.opt = opt;\n    let sel = this.opt.element ? this.opt.element : '*';\n    sel += '[data-markjs]';\n    if (this.opt.className) {\n      sel += `.${this.opt.className}`;\n    }\n    this.log(`Removal selector \"${sel}\"`);\n    this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, node => {\n      this.unwrapMatches(node);\n    }, node => {\n      const matchesSel = DOMIterator.matches(node, sel),\n        matchesExclude = this.matchesExclude(node);\n      if (!matchesSel || matchesExclude) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, this.opt.done);\n  }\n}\n","import MarkJS from './lib/mark';\n\nexport default function Mark(ctx) {\n  const instance = new MarkJS(ctx);\n  this.mark = (sv, opt) => {\n    instance.mark(sv, opt);\n    return this;\n  };\n  this.markRegExp = (sv, opt) => {\n    instance.markRegExp(sv, opt);\n    return this;\n  };\n  this.markRanges = (sv, opt) => {\n    instance.markRanges(sv, opt);\n    return this;\n  };\n  this.unmark = (opt) => {\n    instance.unmark(opt);\n    return this;\n  };\n  return this;\n}","/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    stringifyField: (fieldValue, fieldName) => fieldValue.toString(),\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n","// adapted from https://stackoverflow.com/a/46432113/11613622\nexport class LRUCache {\n    max;\n    cache;\n    constructor(max = 10) {\n        this.max = max;\n        this.cache = new Map();\n    }\n    get(key) {\n        let item = this.cache.get(key);\n        if (item !== undefined) {\n            // refresh key\n            this.cache.delete(key);\n            this.cache.set(key, item);\n        }\n        return item;\n    }\n    set(key, val) {\n        // refresh key\n        if (this.cache.has(key))\n            this.cache.delete(key);\n        // evict oldest\n        else if (this.cache.size === this.max)\n            this.cache.delete(this.first());\n        this.cache.set(key, val);\n    }\n    first() {\n        return this.cache.keys().next().value;\n    }\n    clear() {\n        this.cache.clear();\n    }\n}\n","<script lang=\"ts\" setup>\nimport localSearchIndex from '@localSearchIndex'\nimport {\n  computedAsync,\n  debouncedWatch,\n  onKeyStroke,\n  useEventListener,\n  useLocalStorage,\n  useScrollLock,\n  useSessionStorage\n} from '@vueuse/core'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport Mark from 'mark.js/src/vanilla.js'\nimport MiniSearch, { type SearchResult } from 'minisearch'\nimport { dataSymbol, inBrowser, useRouter } from 'vitepress'\nimport {\n  computed,\n  createApp,\n  markRaw,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n  watchEffect,\n  type Ref\n} from 'vue'\nimport type { ModalTranslations } from '../../../../types/local-search'\nimport { pathToFile } from '../../app/utils'\nimport { escapeRegExp } from '../../shared'\nimport { useData } from '../composables/data'\nimport { LRUCache } from '../support/lru'\nimport { createSearchTranslate } from '../support/translation'\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n}>()\n\nconst el = shallowRef<HTMLElement>()\nconst resultsEl = shallowRef<HTMLElement>()\n\n/* Search */\n\nconst searchIndexData = shallowRef(localSearchIndex)\n\n// hmr\nif (import.meta.hot) {\n  import.meta.hot.accept('/@localSearchIndex', (m) => {\n    if (m) {\n      searchIndexData.value = m.default\n    }\n  })\n}\n\ninterface Result {\n  title: string\n  titles: string[]\n  text?: string\n}\n\nconst vitePressData = useData()\nconst { activate } = useFocusTrap(el, {\n  immediate: true,\n  allowOutsideClick: true,\n  clickOutsideDeactivates: true,\n  escapeDeactivates: true\n})\nconst { localeIndex, theme } = vitePressData\nconst searchIndex = computedAsync(async () =>\n  markRaw(\n    MiniSearch.loadJSON<Result>(\n      (await searchIndexData.value[localeIndex.value]?.())?.default,\n      {\n        fields: ['title', 'titles', 'text'],\n        storeFields: ['title', 'titles'],\n        searchOptions: {\n          fuzzy: 0.2,\n          prefix: true,\n          boost: { title: 4, text: 2, titles: 1 },\n          ...(theme.value.search?.provider === 'local' &&\n            theme.value.search.options?.miniSearch?.searchOptions)\n        },\n        ...(theme.value.search?.provider === 'local' &&\n          theme.value.search.options?.miniSearch?.options)\n      }\n    )\n  )\n)\n\nconst disableQueryPersistence = computed(() => {\n  return (\n    theme.value.search?.provider === 'local' &&\n    theme.value.search.options?.disableQueryPersistence === true\n  )\n})\n\nconst filterText = disableQueryPersistence.value\n  ? ref('')\n  : useSessionStorage('vitepress:local-search-filter', '')\n\nconst showDetailedList = useLocalStorage(\n  'vitepress:local-search-detailed-list',\n  theme.value.search?.provider === 'local' &&\n    theme.value.search.options?.detailedView === true\n)\n\nconst disableDetailedView = computed(() => {\n  return (\n    theme.value.search?.provider === 'local' &&\n    (theme.value.search.options?.disableDetailedView === true ||\n      theme.value.search.options?.detailedView === false)\n  )\n})\n\nconst buttonText = computed(() => {\n  const options = theme.value.search?.options ?? theme.value.algolia\n\n  return (\n    options?.locales?.[localeIndex.value]?.translations?.button?.buttonText ||\n    options?.translations?.button?.buttonText ||\n    'Search'\n  )\n})\n\nwatchEffect(() => {\n  if (disableDetailedView.value) {\n    showDetailedList.value = false\n  }\n})\n\nconst results: Ref<(SearchResult & Result)[]> = shallowRef([])\n\nconst enableNoResults = ref(false)\n\nwatch(filterText, () => {\n  enableNoResults.value = false\n})\n\nconst mark = computedAsync(async () => {\n  if (!resultsEl.value) return\n  return markRaw(new Mark(resultsEl.value))\n}, null)\n\nconst cache = new LRUCache<string, Map<string, string>>(16) // 16 files\n\ndebouncedWatch(\n  () => [searchIndex.value, filterText.value, showDetailedList.value] as const,\n  async ([index, filterTextValue, showDetailedListValue], old, onCleanup) => {\n    if (old?.[0] !== index) {\n      // in case of hmr\n      cache.clear()\n    }\n\n    let canceled = false\n    onCleanup(() => {\n      canceled = true\n    })\n\n    if (!index) return\n\n    // Search\n    results.value = index\n      .search(filterTextValue)\n      .slice(0, 16) as (SearchResult & Result)[]\n    enableNoResults.value = true\n\n    // Highlighting\n    const mods = showDetailedListValue\n      ? await Promise.all(results.value.map((r) => fetchExcerpt(r.id)))\n      : []\n    if (canceled) return\n    for (const { id, mod } of mods) {\n      const mapId = id.slice(0, id.indexOf('#'))\n      let map = cache.get(mapId)\n      if (map) continue\n      map = new Map()\n      cache.set(mapId, map)\n      const comp = mod.default ?? mod\n      if (comp?.render || comp?.setup) {\n        const app = createApp(comp)\n        // Silence warnings about missing components\n        app.config.warnHandler = () => {}\n        app.provide(dataSymbol, vitePressData)\n        Object.defineProperties(app.config.globalProperties, {\n          $frontmatter: {\n            get() {\n              return vitePressData.frontmatter.value\n            }\n          },\n          $params: {\n            get() {\n              return vitePressData.page.value.params\n            }\n          }\n        })\n        const div = document.createElement('div')\n        app.mount(div)\n        const headings = div.querySelectorAll('h1, h2, h3, h4, h5, h6')\n        headings.forEach((el) => {\n          const href = el.querySelector('a')?.getAttribute('href')\n          const anchor = href?.startsWith('#') && href.slice(1)\n          if (!anchor) return\n          let html = ''\n          while ((el = el.nextElementSibling!) && !/^h[1-6]$/i.test(el.tagName))\n            html += el.outerHTML\n          map!.set(anchor, html)\n        })\n        app.unmount()\n      }\n      if (canceled) return\n    }\n\n    const terms = new Set<string>()\n\n    results.value = results.value.map((r) => {\n      const [id, anchor] = r.id.split('#')\n      const map = cache.get(id)\n      const text = map?.get(anchor) ?? ''\n      for (const term in r.match) {\n        terms.add(term)\n      }\n      return { ...r, text }\n    })\n\n    await nextTick()\n    if (canceled) return\n\n    await new Promise((r) => {\n      mark.value?.unmark({\n        done: () => {\n          mark.value?.markRegExp(formMarkRegex(terms), { done: r })\n        }\n      })\n    })\n\n    const excerpts = el.value?.querySelectorAll('.result .excerpt') ?? []\n    for (const excerpt of excerpts) {\n      excerpt\n        .querySelector('mark[data-markjs=\"true\"]')\n        ?.scrollIntoView({ block: 'center' })\n    }\n    // FIXME: without this whole page scrolls to the bottom\n    resultsEl.value?.firstElementChild?.scrollIntoView({ block: 'start' })\n  },\n  { debounce: 200, immediate: true }\n)\n\nasync function fetchExcerpt(id: string) {\n  const file = pathToFile(id.slice(0, id.indexOf('#')))\n  try {\n    if (!file) throw new Error(`Cannot find file for id: ${id}`)\n    return { id, mod: await import(/*@vite-ignore*/ file) }\n  } catch (e) {\n    console.error(e)\n    return { id, mod: {} }\n  }\n}\n\n/* Search input focus */\n\nconst searchInput = ref<HTMLInputElement>()\nconst disableReset = computed(() => {\n  return filterText.value?.length <= 0\n})\nfunction focusSearchInput(select = true) {\n  searchInput.value?.focus()\n  select && searchInput.value?.select()\n}\n\nonMounted(() => {\n  focusSearchInput()\n})\n\nfunction onSearchBarClick(event: PointerEvent) {\n  if (event.pointerType === 'mouse') {\n    focusSearchInput()\n  }\n}\n\n/* Search keyboard selection */\n\nconst selectedIndex = ref(-1)\nconst disableMouseOver = ref(true)\n\nwatch(results, (r) => {\n  selectedIndex.value = r.length ? 0 : -1\n  scrollToSelectedResult()\n})\n\nfunction scrollToSelectedResult() {\n  nextTick(() => {\n    const selectedEl = document.querySelector('.result.selected')\n    selectedEl?.scrollIntoView({ block: 'nearest' })\n  })\n}\n\nonKeyStroke('ArrowUp', (event) => {\n  event.preventDefault()\n  selectedIndex.value--\n  if (selectedIndex.value < 0) {\n    selectedIndex.value = results.value.length - 1\n  }\n  disableMouseOver.value = true\n  scrollToSelectedResult()\n})\n\nonKeyStroke('ArrowDown', (event) => {\n  event.preventDefault()\n  selectedIndex.value++\n  if (selectedIndex.value >= results.value.length) {\n    selectedIndex.value = 0\n  }\n  disableMouseOver.value = true\n  scrollToSelectedResult()\n})\n\nconst router = useRouter()\n\nonKeyStroke('Enter', (e) => {\n  if (e.isComposing) return\n\n  if (e.target instanceof HTMLButtonElement && e.target.type !== 'submit')\n    return\n\n  const selectedPackage = results.value[selectedIndex.value]\n  if (e.target instanceof HTMLInputElement && !selectedPackage) {\n    e.preventDefault()\n    return\n  }\n\n  if (selectedPackage) {\n    router.go(selectedPackage.id)\n    emit('close')\n  }\n})\n\nonKeyStroke('Escape', () => {\n  emit('close')\n})\n\n// Translations\nconst defaultTranslations: { modal: ModalTranslations } = {\n  modal: {\n    displayDetails: 'Display detailed list',\n    resetButtonTitle: 'Reset search',\n    backButtonTitle: 'Close search',\n    noResultsText: 'No results for',\n    footer: {\n      selectText: 'to select',\n      selectKeyAriaLabel: 'enter',\n      navigateText: 'to navigate',\n      navigateUpKeyAriaLabel: 'up arrow',\n      navigateDownKeyAriaLabel: 'down arrow',\n      closeText: 'to close',\n      closeKeyAriaLabel: 'escape'\n    }\n  }\n}\n\nconst translate = createSearchTranslate(defaultTranslations)\n\n// Back\n\nonMounted(() => {\n  // Prevents going to previous site\n  window.history.pushState(null, '', null)\n})\n\nuseEventListener('popstate', (event) => {\n  event.preventDefault()\n  emit('close')\n})\n\n/** Lock body */\nconst isLocked = useScrollLock(inBrowser ? document.body : null)\n\nonMounted(() => {\n  nextTick(() => {\n    isLocked.value = true\n    nextTick().then(() => activate())\n  })\n})\n\nonBeforeUnmount(() => {\n  isLocked.value = false\n})\n\nfunction resetSearch() {\n  filterText.value = ''\n  nextTick().then(() => focusSearchInput(false))\n}\n\nfunction formMarkRegex(terms: Set<string>) {\n  return new RegExp(\n    [...terms]\n      .sort((a, b) => b.length - a.length)\n      .map((term) => `(${escapeRegExp(term)})`)\n      .join('|'),\n    'gi'\n  )\n}\n\nfunction onMouseMove(e: MouseEvent) {\n  if (!disableMouseOver.value) return\n  const el = (e.target as HTMLElement)?.closest<HTMLAnchorElement>('.result')\n  const index = Number.parseInt(el?.dataset.index!)\n  if (index >= 0 && index !== selectedIndex.value) {\n    selectedIndex.value = index\n  }\n  disableMouseOver.value = false\n}\n</script>\n\n<template>\n  <Teleport to=\"body\">\n    <div\n      ref=\"el\"\n      role=\"button\"\n      :aria-owns=\"results?.length ? 'localsearch-list' : undefined\"\n      aria-expanded=\"true\"\n      aria-haspopup=\"listbox\"\n      aria-labelledby=\"localsearch-label\"\n      class=\"VPLocalSearchBox\"\n    >\n      <div class=\"backdrop\" @click=\"$emit('close')\" />\n\n      <div class=\"shell\">\n        <form\n          class=\"search-bar\"\n          @pointerup=\"onSearchBarClick($event)\"\n          @submit.prevent=\"\"\n        >\n          <label\n            :title=\"buttonText\"\n            id=\"localsearch-label\"\n            for=\"localsearch-input\"\n          >\n            <span aria-hidden=\"true\" class=\"vpi-search search-icon local-search-icon\" />\n          </label>\n          <div class=\"search-actions before\">\n            <button\n              class=\"back-button\"\n              :title=\"translate('modal.backButtonTitle')\"\n              @click=\"$emit('close')\"\n            >\n              <span class=\"vpi-arrow-left local-search-icon\" />\n            </button>\n          </div>\n          <input\n            ref=\"searchInput\"\n            v-model=\"filterText\"\n            :aria-activedescendant=\"selectedIndex > -1 ? ('localsearch-item-' + selectedIndex) : undefined\"\n            aria-autocomplete=\"both\"\n            :aria-controls=\"results?.length ? 'localsearch-list' : undefined\"\n            aria-labelledby=\"localsearch-label\"\n            autocapitalize=\"off\"\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            class=\"search-input\"\n            id=\"localsearch-input\"\n            enterkeyhint=\"go\"\n            maxlength=\"64\"\n            :placeholder=\"buttonText\"\n            spellcheck=\"false\"\n            type=\"search\"\n          />\n          <div class=\"search-actions\">\n            <button\n              v-if=\"!disableDetailedView\"\n              class=\"toggle-layout-button\"\n              type=\"button\"\n              :class=\"{ 'detailed-list': showDetailedList }\"\n              :title=\"translate('modal.displayDetails')\"\n              @click=\"\n                selectedIndex > -1 && (showDetailedList = !showDetailedList)\n              \"\n            >\n              <span class=\"vpi-layout-list local-search-icon\" />\n            </button>\n\n            <button\n              class=\"clear-button\"\n              type=\"reset\"\n              :disabled=\"disableReset\"\n              :title=\"translate('modal.resetButtonTitle')\"\n              @click=\"resetSearch\"\n            >\n              <span class=\"vpi-delete local-search-icon\" />\n            </button>\n          </div>\n        </form>\n\n        <ul\n          ref=\"resultsEl\"\n          :id=\"results?.length ? 'localsearch-list' : undefined\"\n          :role=\"results?.length ? 'listbox' : undefined\"\n          :aria-labelledby=\"results?.length ? 'localsearch-label' : undefined\"\n          class=\"results\"\n          @mousemove=\"onMouseMove\"\n        >\n          <li\n            v-for=\"(p, index) in results\"\n            :key=\"p.id\"\n            :id=\"'localsearch-item-' + index\"\n            :aria-selected=\"selectedIndex === index ? 'true' : 'false'\"\n            role=\"option\"\n          >\n            <a\n              :href=\"p.id\"\n              class=\"result\"\n              :class=\"{\n                selected: selectedIndex === index\n              }\"\n              :aria-label=\"[...p.titles, p.title].join(' > ')\"\n              @mouseenter=\"!disableMouseOver && (selectedIndex = index)\"\n              @focusin=\"selectedIndex = index\"\n              @click=\"$emit('close')\"\n              :data-index=\"index\"\n            >\n              <div>\n                <div class=\"titles\">\n                  <span class=\"title-icon\">#</span>\n                  <span\n                    v-for=\"(t, index) in p.titles\"\n                    :key=\"index\"\n                    class=\"title\"\n                  >\n                    <span class=\"text\" v-html=\"t\" />\n                    <span class=\"vpi-chevron-right local-search-icon\" />\n                  </span>\n                  <span class=\"title main\">\n                    <span class=\"text\" v-html=\"p.title\" />\n                  </span>\n                </div>\n\n                <div v-if=\"showDetailedList\" class=\"excerpt-wrapper\">\n                  <div v-if=\"p.text\" class=\"excerpt\" inert>\n                    <div class=\"vp-doc\" v-html=\"p.text\" />\n                  </div>\n                  <div class=\"excerpt-gradient-bottom\" />\n                  <div class=\"excerpt-gradient-top\" />\n                </div>\n              </div>\n            </a>\n          </li>\n          <li\n            v-if=\"filterText && !results.length && enableNoResults\"\n            class=\"no-results\"\n          >\n            {{ translate('modal.noResultsText') }} \"<strong>{{ filterText }}</strong\n            >\"\n          </li>\n        </ul>\n\n        <div class=\"search-keyboard-shortcuts\">\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.navigateUpKeyAriaLabel')\">\n              <span class=\"vpi-arrow-up navigate-icon\" />\n            </kbd>\n            <kbd :aria-label=\"translate('modal.footer.navigateDownKeyAriaLabel')\">\n              <span class=\"vpi-arrow-down navigate-icon\" />\n            </kbd>\n            {{ translate('modal.footer.navigateText') }}\n          </span>\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.selectKeyAriaLabel')\">\n              <span class=\"vpi-corner-down-left navigate-icon\" />\n            </kbd>\n            {{ translate('modal.footer.selectText') }}\n          </span>\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.closeKeyAriaLabel')\">esc</kbd>\n            {{ translate('modal.footer.closeText') }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<style scoped>\n.VPLocalSearchBox {\n  position: fixed;\n  z-index: 100;\n  inset: 0;\n  display: flex;\n}\n\n.backdrop {\n  position: absolute;\n  inset: 0;\n  background: var(--vp-backdrop-bg-color);\n  transition: opacity 0.5s;\n}\n\n.shell {\n  position: relative;\n  padding: 12px;\n  margin: 64px auto;\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  background: var(--vp-local-search-bg);\n  width: min(100vw - 60px, 900px);\n  height: min-content;\n  max-height: min(100vh - 128px, 900px);\n  border-radius: 6px;\n}\n\n@media (max-width: 767px) {\n  .shell {\n    margin: 0;\n    width: 100vw;\n    height: 100vh;\n    max-height: none;\n    border-radius: 0;\n  }\n}\n\n.search-bar {\n  border: 1px solid var(--vp-c-divider);\n  border-radius: 4px;\n  display: flex;\n  align-items: center;\n  padding: 0 12px;\n  cursor: text;\n}\n\n@media (max-width: 767px) {\n  .search-bar {\n    padding: 0 8px;\n  }\n}\n\n.search-bar:focus-within {\n  border-color: var(--vp-c-brand-1);\n}\n\n.local-search-icon {\n  display: block;\n  font-size: 18px;\n}\n\n.navigate-icon {\n  display: block;\n  font-size: 14px;\n}\n\n.search-icon {\n  margin: 8px;\n}\n\n@media (max-width: 767px) {\n  .search-icon {\n    display: none;\n  }\n}\n\n.search-input {\n  padding: 6px 12px;\n  font-size: inherit;\n  width: 100%;\n}\n\n@media (max-width: 767px) {\n  .search-input {\n    padding: 6px 4px;\n  }\n}\n\n.search-actions {\n  display: flex;\n  gap: 4px;\n}\n\n@media (any-pointer: coarse) {\n  .search-actions {\n    gap: 8px;\n  }\n}\n\n@media (min-width: 769px) {\n  .search-actions.before {\n    display: none;\n  }\n}\n\n.search-actions button {\n  padding: 8px;\n}\n\n.search-actions button:not([disabled]):hover,\n.toggle-layout-button.detailed-list {\n  color: var(--vp-c-brand-1);\n}\n\n.search-actions button.clear-button:disabled {\n  opacity: 0.37;\n}\n\n.search-keyboard-shortcuts {\n  font-size: 0.8rem;\n  opacity: 75%;\n  display: flex;\n  flex-wrap: wrap;\n  gap: 16px;\n  line-height: 14px;\n}\n\n.search-keyboard-shortcuts span {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n@media (max-width: 767px) {\n  .search-keyboard-shortcuts {\n    display: none;\n  }\n}\n\n.search-keyboard-shortcuts kbd {\n  background: rgba(128, 128, 128, 0.1);\n  border-radius: 4px;\n  padding: 3px 6px;\n  min-width: 24px;\n  display: inline-block;\n  text-align: center;\n  vertical-align: middle;\n  border: 1px solid rgba(128, 128, 128, 0.15);\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.1);\n}\n\n.results {\n  display: flex;\n  flex-direction: column;\n  gap: 6px;\n  overflow-x: hidden;\n  overflow-y: auto;\n  overscroll-behavior: contain;\n}\n\n.result {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  border-radius: 4px;\n  transition: none;\n  line-height: 1rem;\n  border: solid 2px var(--vp-local-search-result-border);\n  outline: none;\n}\n\n.result > div {\n  margin: 12px;\n  width: 100%;\n  overflow: hidden;\n}\n\n@media (max-width: 767px) {\n  .result > div {\n    margin: 8px;\n  }\n}\n\n.titles {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 4px;\n  position: relative;\n  z-index: 1001;\n  padding: 2px 0;\n}\n\n.title {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.title.main {\n  font-weight: 500;\n}\n\n.title-icon {\n  opacity: 0.5;\n  font-weight: 500;\n  color: var(--vp-c-brand-1);\n}\n\n.title svg {\n  opacity: 0.5;\n}\n\n.result.selected {\n  --vp-local-search-result-bg: var(--vp-local-search-result-selected-bg);\n  border-color: var(--vp-local-search-result-selected-border);\n}\n\n.excerpt-wrapper {\n  position: relative;\n}\n\n.excerpt {\n  opacity: 50%;\n  pointer-events: none;\n  max-height: 140px;\n  overflow: hidden;\n  position: relative;\n  margin-top: 4px;\n}\n\n.result.selected .excerpt {\n  opacity: 1;\n}\n\n.excerpt :deep(*) {\n  font-size: 0.8rem !important;\n  line-height: 130% !important;\n}\n\n.titles :deep(mark),\n.excerpt :deep(mark) {\n  background-color: var(--vp-local-search-highlight-bg);\n  color: var(--vp-local-search-highlight-text);\n  border-radius: 2px;\n  padding: 0 2px;\n}\n\n.excerpt :deep(.vp-code-group) .tabs {\n  display: none;\n}\n\n.excerpt :deep(.vp-code-group) div[class*='language-'] {\n  border-radius: 8px !important;\n}\n\n.excerpt-gradient-bottom {\n  position: absolute;\n  bottom: -1px;\n  left: 0;\n  width: 100%;\n  height: 8px;\n  background: linear-gradient(transparent, var(--vp-local-search-result-bg));\n  z-index: 1000;\n}\n\n.excerpt-gradient-top {\n  position: absolute;\n  top: -1px;\n  left: 0;\n  width: 100%;\n  height: 8px;\n  background: linear-gradient(var(--vp-local-search-result-bg), transparent);\n  z-index: 1000;\n}\n\n.result.selected .titles,\n.result.selected .title-icon {\n  color: var(--vp-c-brand-1) !important;\n}\n\n.no-results {\n  font-size: 0.9rem;\n  text-align: center;\n  padding: 12px;\n}\n\nsvg {\n  flex: none;\n}\n</style>\n","import { toArray, unrefElement, tryOnScopeDispose } from '@vueuse/core';\nimport { notNullish } from '@vueuse/shared';\nimport { createFocusTrap } from 'focus-trap';\nimport { shallowRef, computed, toValue, watch } from 'vue';\n\nfunction useFocusTrap(target, options = {}) {\n  let trap;\n  const { immediate, ...focusTrapOptions } = options;\n  const hasFocus = shallowRef(false);\n  const isPaused = shallowRef(false);\n  const activate = (opts) => trap && trap.activate(opts);\n  const deactivate = (opts) => trap && trap.deactivate(opts);\n  const pause = () => {\n    if (trap) {\n      trap.pause();\n      isPaused.value = true;\n    }\n  };\n  const unpause = () => {\n    if (trap) {\n      trap.unpause();\n      isPaused.value = false;\n    }\n  };\n  const targets = computed(() => {\n    const _targets = toValue(target);\n    return toArray(_targets).map((el) => {\n      const _el = toValue(el);\n      return typeof _el === \"string\" ? _el : unrefElement(_el);\n    }).filter(notNullish);\n  });\n  watch(\n    targets,\n    (els) => {\n      if (!els.length)\n        return;\n      trap = createFocusTrap(els, {\n        ...focusTrapOptions,\n        onActivate() {\n          hasFocus.value = true;\n          if (options.onActivate)\n            options.onActivate();\n        },\n        onDeactivate() {\n          hasFocus.value = false;\n          if (options.onDeactivate)\n            options.onDeactivate();\n        }\n      });\n      if (immediate)\n        activate();\n    },\n    { flush: \"post\" }\n  );\n  tryOnScopeDispose(() => deactivate());\n  return {\n    hasFocus,\n    isPaused,\n    activate,\n    deactivate,\n    pause,\n    unpause\n  };\n}\n\nexport { useFocusTrap };\n"],"file":"assets/chunks/VPLocalSearchBox.Dyj_mw8v.js"}